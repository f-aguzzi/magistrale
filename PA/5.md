# Tipizzazione

Una componente importante della sicurezza di un sistema (intesa come *safety*, protezione da falle intrinseche, e non come *security* ovvero resistenza agli attacchi esterni) è il sistema dei tipi. Definiamo *tipo* un insieme di valori omogenei e di operazioni su di esso definite. I tipi definiscono concetti che possono essere elementari (tipi base che rappresentano numeri, lettere, ...) o complessi (collezioni e classi, che sono composizioni di tipi base). L'uso dei tipi permette al compilatore di interpretare correttamente i dati in memoria, e di controllare che essi siano definiti e utilizzati correttamente dall'utente.

Un possibile errore a livello *hardware* può consistere nella confusione tra dati e programmi. Entrambe le categorie sono indistinguibilmente valori binari in memoria centrale. Come descritto in precedenza, questa ambiguità nella rappresentazione fisica può essere utilizzata deliberatamente per produrre un attacco che inserisca codice eseguibile malevolo in un'area altrimenti destinata ai dati. Esistono inoltre errori semantici. La rappresentazione binaria di uno stesso valore è diversa a seconda che si tratti di un intero o di un numero a virgola mobile. La lettura di una variabile secondo la convenzione sbagliata porta ad errori aritmetici. Nei linguaggi di programmazione ad oggetti il controllo dei tipi deve imporre il rispetto della gerarchia di ereditarietà. Il membro di una sottoclasse può essere promosso a membro di una superclasse perché possiede tutti i campi e metodi necessari, ma non vale il contrario.

Un linguaggio di programmazione si dice *type safe* se non è possibile scrivere con esso un programma in grado di violare il suo sistema di tipi. Le violazioni possono includere la confusione tra tipi, la chiamata di dati come se fossero funzioni, o l'accesso a zone di memoria riservate ad altri dati. La proprietà di prevenzione di quest'ultima problematica è chiamata *memory safety*. C e C++ non sono *type safe* perché le operazioni di *casting* incontrollato e l'aritmetica dei puntatori permettono di violare sia la *type safety* che la *memory safety*. Questo perché C punta alla velocità e all'efficienza, lasciando al programmatore la responsabilità per la sicurezza. Possiamo rendere C più sicuro riducendo l'uso delle feature pericolose. Pascal è parzialmente *type safe* perché richiede la deallocazione manuale della memoria, con il conseguente problema dei *dangling pointers*.  Java, Python e Lisp sono considerati *type safe*. Laddove non sia possibile usare linguaggi *type safe*, sono comunque disponibili *tool* esterni di analisi, pur sempre limitati dal precedente nominato problema di Turing. 

Elenchiamo in dettaglio le problematiche che rendono C e C++ non *type safe*. Innanzitutto, il *casting* è incontrollato e permette il passaggio tra tipi di dimensioni incompatibili, con rischio di perdita di informazione e *overflow*. Permette inoltre di trasformare tipi per variabili in tipi per funzioni, e dunque di chiamare aree di memoria per dati come se fossero codice. Non solo non esistono meccanismi che impediscano il dereferenziamento dei puntatori nulli, ma addirittura lo standard del linguaggio non definisce cosa fare in tale evenienza. Il valore nullo del puntatore è semplicemente lo 0. La funzione `malloc`  usata per l'allocazione dinamica restituisce il valore `null` quando fallisce, e dunque anch'essa può essere fonte di comportamento indefinito. In alcuni sistemi è il sistema operativo a restituire un *segmentation fault* quando si tenta di accedere ad un puntatore nullo, ma questa protezione si perde quando il puntatore nullo è usato per accedere ad una cella di un array diversa dalla prima. Problemi simili si presentano con l'algebra dei puntatori. Ad esempio, `*(p+i)` permette di accedere a celle contigue che potrebbero avere un tipo diverso rispetto a quello di `p`. Equivalentemente, `x = *(p+i)` può permettere di salvare in `x` variabili del tipo sbagliato. Infine esistono problematiche di accesso non valido. Le violazioni possono essere spaziali (*out of bound*, uscire dall'area di memoria assegnata ad un *array*), o temporali (*dangling pointers*, puntatori ad aree deallocate e potenzialmente riscritte). Per quanto riguarda l'accesso non valido, l'allocazione dinamica è meno affetta da questa problematica, ma anche l'allocazione statica può essere resa sicura evitando di non passare mai alla funzione chiamante riferimenti alle variabili locali di una funzione chiamata.

Il controllo a compile time è obbligato a rifiutare programmi potenzialmente validi perché non è possibile determinarne staticamente la correttezza (sarebbe come risolvere il problema di Turing). Il controllo a runtime non soffre di questo problema ma rallenta l'esecuzione.
Java utilizza un approccio ibrido introducendo in compilazione dei controlli da effettuare in esecuzione in presenza di problemi di tipo non risolvibili staticamente (ad esempio casting tra classi imparentate).

Il controllo dei tipi può essere effettuato in compilazione o in esecuzione. ML, C, C++ e Java controllano i tipi in compilazione. Python e Lisp li controllano in esecuzione. Il controllo in compilazione deve necessariamente rifiutare programmi potenzialmente validi perché non è possibile determinarne staticamente la correttezza. Se il loro flusso di controllo è programmatico, infatti, determinarne a priori la traiettoria sarebbe equivalente alla risoluzione, impossibile, del problema di *halting*. Il controllo in esecuzione non soffre di questa problematica, ma la maggiore libertà di programmazione si paga in riduzione della velocità, a causa del rallentamento dovuto all'accertamento dinamico dei tipi. Un altro problema del controllo in esecuzione è che gli errori di tipo non vengono individuati fino al momento dell'esecuzione della porzione di codice che li contiene. Java impiega un approccio ibrido. I controlli che sono impossibili da risolvere staticamente sono deferiti al momento dell'esecuzione tramite l'iniezione, al momento della compilazione, di codice di controllo da eseguire dinamicamente. Un esempio di questa strategia riguarda il controllo della promozione a superclasse.

Una distinzione ulteriore tra linguaggi è tra tipizzazione forte e tipizzazione dinamica. Nel primo caso, il tipo di una variabile è fissato per tutto il suo ciclo di vita. Nel secondo, una variabile può cambiare tipo al momento del riassegnamento del suo valore. Alla prima categoria appartengono C, C++ e Java. Alla seconda categoria appartiene Python. Un concetto correlato è l'inferenza dei tipi. Il linguaggio può determinare automaticamente il tipo di una variabile in base al contenuto assegnatole dall'utente. L'algoritmo di inferenza del tipo lavora in tre fasi. Dapprima assassegna un tipo ad ogni espressione e sottoespressione, usando tipi noti. Dopodiché, genera vincoli sui tipi usando l'albero sintattico dell'espressione. Infine, risolve i vincoli per unificazione. Python inferisce dinamicamente i tipi, ma essi sono anche specificabili manualmente. La tipizzazione è dinamica ma ben definita. Essa si perde nella definizione delle funzioni, in cui non è necessario specificare né il tipo dei parametri né il tipo del valore ritorno. Vale in questo caso il concetto di *duck typing* (*if it walks like a duck and quacks like a duck, then it's a duck*), secondo il quale non è necessario lanciare errori di tipo fin quando i valori ricevuti rispettano il contratto minimo necessario, ovvero hanno a disposizione quei campi e quei metodi richiesti durante l'esecuzione. Java, dalla versione 10, introduce la keyword `var` per la dichiarazione di variabili con inferenza automatica del tipo. Dopo un primo assegnamento, il tipo rimane fisso e non modificabile.


